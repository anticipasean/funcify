import "ensemble_type.stg"

function_type(ensemble_type_name, arity="", ensemble_type_package=[], package=[], witness_type="WT", next_type_variable="", type_variables=[], implements_supplier=false, implements_function=false) ::= <<
package <package; separator=".">;

<null_check_import()>
<ensemble_type_import(ensemble_type_name, ensemble_type_package)>
import <package; separator=".">.Fn<arity>.<witness_type>;
<if(implements_supplier)>
import java.util.function.Supplier;

public interface <function_type_declaration(arity, type_variables)> extends <ensemble_type_declaration(ensemble_type_name, witness_type, type_variables)>, Supplier\<<first(type_variables)>\> {
<elseif(implements_function)>
<ensemble_type_import("Solo", ensemble_type_package)>
<java_util_func_import()>

public interface <function_type_declaration(arity, type_variables)> extends <ensemble_type_declaration(ensemble_type_name, witness_type, type_variables)>, Function\<<type_variables; separator=", ">\> {
<else>
<ensemble_type_import("Solo", ensemble_type_package)>

public interface <function_type_declaration(arity, type_variables)> extends <ensemble_type_declaration(ensemble_type_name, witness_type, type_variables)> {
<endif>

<witness_type_definition(witness_type)>

<narrow_kind_functions(arity, type_variables, witness_type, ensemble_type_name)>

<apply_method(type_variables)>

<map_method(arity, type_variables, next_type_variable)>

<and_then_method(arity, type_variables, next_type_variable, implements_function)>

<flat_map_method(arity, type_variables, next_type_variable)>

}
>>

function_type_declaration(arity="0", type_variables=[]) ::= "Fn<arity>\<<type_variables; separator={, }>>"

witness_type_definition(witness_type) ::= <<
    static enum <witness_type> {

    }
>>

narrow_kind_functions(arity="0", type_variables=[], witness_type="WT", ensemble_type_name="") ::= <<
    static \<<type_variables; separator=", ">\> <function_type_declaration(arity, type_variables)> narrowK(final <recursive_solo_type_declaration(witness_type, type_variables)> wideInstance) {
        return (<function_type_declaration(arity, type_variables)>) wideInstance;
    }

    static \<<type_variables; separator=", ">\> <function_type_declaration(arity, type_variables)> narrowK(final <ensemble_type_declaration(ensemble_type_name, witness_type, type_variables)> wideInstance) {
        return (<function_type_declaration(arity, type_variables)>) wideInstance;
    }
>>

apply_method(type_variables=[]) ::= <<
    <last(type_variables)> apply(<reverse(rest(reverse(type_variables))):{tv | final <tv> input<i>};anchor,separator=",\n">);
>>

map_method(arity="0", type_variables=[], next_type_variable="") ::= <<
    default \<<next_type_variable>\> <function_type_declaration(arity, [reverse(rest(reverse(type_variables))), next_type_variable])> map(<function_type_parameter_declaration(last(type_variables), next_type_variable)>) {
        <null_check("function")>;
        return (<reverse(rest(reverse(type_variables))):{tv | <tv> input<i>};separator=", ">) -> {
            return function.apply(this.apply(<reverse(rest(reverse(type_variables))):{tv | input<i>};anchor,separator=",\n">));
        };
    }
>>

and_then_method(arity="0", type_variables=[], next_type_variable="", implements_function=false) ::= <<
    <if(implements_function)><\\>
    <else><\\>
    default \<<next_type_variable>\> <function_type_declaration(arity, [reverse(rest(reverse(type_variables))), next_type_variable])> andThen(<function_type_parameter_declaration(last(type_variables), next_type_variable)>) {
        return map(function);
    }
    <endif>
>>

flat_map_method(arity="0", type_variables=[], next_type_variable="") ::= <<
    default \<<next_type_variable>\> <function_type_declaration(arity, [reverse(rest(reverse(type_variables))), next_type_variable])> flatMap(final Fn1\<? super <last(type_variables)>, ? extends Fn<arity>\<<reverse(rest(reverse(type_variables))):{tv | ? super <tv>};separator=", ">, ? extends <next_type_variable>\>> function) {
        <null_check("function")>;
        return (<reverse(rest(reverse(type_variables))):{tv | <tv> input<i>};separator=", ">) -> {
            return function.apply(this.apply(<reverse(rest(reverse(type_variables))):{tv | input<i>};anchor,separator=",\n">)).apply(<reverse(rest(reverse(type_variables))):{tv | input<i>};anchor,separator=",\n">);
        };
    }
>>

function_type_parameter_declaration(type_variables, next_type_variable) ::= "final Fn1\<<type_variables:{tv | ? super <tv>};separator={, }>, ? extends <next_type_variable>> function"