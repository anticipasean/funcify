import "wrappable_disjunct_factory_type.stg"


zippable_disjunct_factory_type(class_name,
                               implemented_type,
                               container_type,
                               package=[],
                               witness_type="WT",
                               type_variables=[],
                               ensemble_type_package=[],
                               zip_impl_sequences=[]) ::= <<
package <package; separator=".">;

<ensemble_type_import(implemented_type.type_name, implemented_type.type_package)>
<ensemble_type_import(container_type.type_name, container_type.type_package)>
<null_check_import()>
<java_util_func_import()>
<zip_impl_sequences:{zis|import funcify.function.Fn<length(trunc(first(zis.function)))>};separator=";\n">;

public interface <ensemble_type_declaration(class_name, witness_type, type_variables)> extends <ensemble_type_declaration(implemented_type.type_name, witness_type, type_variables)> {

<zip_impl_sequences:{zis | <disjunct_zip_method(container_type, zis, i, witness_type)>};separator="\n\n">

}
>>

disjunct_zip_method(container_type, zip_impl_seq, suffix="", witness_type="WT") ::= <<
    default \<<[zip_impl_seq.other:{o |<o;separator=", ">},zip_impl_seq.next:{n|<n>}];separator=", ">\> <ensemble_type_declaration(container_type.type_name,
                                                                                                                                   witness_type,
                                                                                                                                   zip_impl_seq.next)> zip<suffix>(<disjunct_zip_method_parameters(container_type,
                                                                                                                                                                                                   witness_type,
                                                                                                                                                                                                   zip_impl_seq)>) {
        <[first(zip_impl_seq.given)]:{tv|container<tv>}:null_check()>;
        <zip_impl_seq.other:{o|container<first(o)>}:null_check();anchor,separator=";\n">;
        <zip_impl_seq.function:{f|zipper<i>}:null_check();anchor,separator=";\n">;
        <disjunct_unwrap(zip_impl_seq.function, zip_impl_seq.function)>
    }
>>

disjunct_zip_method_parameters(container_type, witness_type, zip_impl_seq) ::= <<
<[disjunct_zip_method_container_parameter(container_type, witness_type, zip_impl_seq.given, [zip_impl_seq.given]),
  zip_impl_seq.other:{o | <disjunct_zip_method_container_parameter(container_type, witness_type, o, [o])>},
  zip_impl_seq.function:{f | <disjunct_zip_method_function_parameter(f, i)>}];anchor,separator=",\n">
>>

disjunct_zip_method_container_parameter(container_type, witness_type="WT", type_variables=[], suffix="") ::= <<
final <ensemble_type_declaration(container_type.type_name, witness_type, type_variables)> container<suffix>
>>

disjunct_zip_method_function_parameter(type_variables, suffix="0") ::= <<
final Fn<length(trunc(type_variables))>\<<trunc(type_variables):{tv|? super <tv>};separator=", ">, ? extends <last(type_variables)>\> zipper<suffix>
>>

disjunct_unwrap(remaining_ftv, full_ftv) ::= <<
<remaining_ftv:{ ftvs |
this.unwrap(container<[ftvs]>, (<first(ftvs)> input<first(ftvs)>) -> {
        <disjunct_unwrap_inner(trunc(rest(ftvs)), ftvs)>
    \}};separator=",\n">
>>

disjunct_unwrap_inner(remaining_ftv,full_ftv) ::= <<
return this.unwrap(container<first(remaining_ftv)>, (<first(remaining_ftv)> input<first(remaining_ftv)>) -> {
        <if(rest(remaining_ftv))><disjunct_unwrap_inner(rest(remaining_ftv), full_ftv)><else>return zipper.apply(<trunc(full_ftv):{f|input<f>};anchor,separator=",\n">);<endif>
    });
>>